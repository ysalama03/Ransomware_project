#!/usr/bin/env python3
"""
Static Antimalware Analyzer
---------------------------
A tool for analyzing executable files to detect potential ransomware
based on static analysis of imports, functions, strings, and entropy.
"""

import os
import sys
import math
import pefile
import subprocess
import argparse
import re
import yara
from collections import Counter

# Lists of suspicious DLLs and functions based on the specifications
SUSPICIOUS_DLLS = {
    # Crypto DLLs
    'rundll32.dll', 'advapi32.dll', 'bcrypt.dll', 'ncrypt.dll', 'crypt32.dll',
    
    # File system enumeration
    'kernel32.dll', 'shell32.dll', 'shlwapi.dll', 'ntdll.dll', 'ole32.dll',
    
    # Internet requests
    'wininet.dll', 'winhttp.dll', 'ws2_32.dll', 'urlmon.dll', 'httpapi.dll', 'dnsapi.dll',
}

SUSPICIOUS_FUNCTIONS = {
    # Dynamic loading
    'LoadLibrary', 'GetProcAddress',
    
    # File enumeration
    'FindFirstFile', 'FindNextFile', 'FindClose',
    
    # File operations
    'CreateFile', 'ReadFile', 'WriteFile', 'DeleteFile', 'RemoveDirectory',
    'SetFileAttributes', 'GetLogicalDrives', 'GetDriveType',
    
    # Crypto functions
    'CryptAcquireContext', 'CryptGenKey', 'CryptEncrypt', 'CryptDecrypt',
    'BCryptEncrypt', 'BCryptGenRandom',
    
    # Network/Internet
    'InternetOpen', 'InternetConnect', 'HttpOpenRequest', 'HttpSendRequest',
    'WinHttpOpen', 'WinHttpConnect', 'WinHttpSendRequest',
    'socket', 'connect', 'send', 'recv',
    'URLDownloadToFile',
    
    # Process manipulation
    'OpenProcess', 'VirtualAlloc', 'VirtualAllocEx',
    'WriteProcessMemory', 'ReadProcessMemory', 'CreateRemoteThread',
    
    # Privilege escalation
    'AdjustTokenPrivileges', 'OpenProcessToken',
    
    # Anti-debugging
    'IsDebuggerPresent', 'CheckRemoteDebuggerPresent', 'NtQueryInformationProcess',
    
    # Registry
    'RegOpenKey', 'RegSetValue', 'RegCreateKey',
    
    # Services
    'CreateService', 'OpenService', 'StartService',
    
    # File copying
    'CopyFile',
    
    # Process execution
    'system', 'ShellExecute', 'CreateProcess',
    
    # Disk operations
    'DeleteVolumeMountPoint', 'DeviceIoControl',
    
    # Evasion techniques
    'Sleep', 'GetTickCount', 'QueryPerformanceCounter', 'NtDelayExecution',
}

# Typical benign section names
NORMAL_SECTIONS = {
    '.text', '.rdata', '.data', '.rsrc', '.reloc',
    '.edata', '.idata', '.pdata', '.bss', '.tls',
    '.rodata', '.CRT'
}

# Suspicious strings to look for
SUSPICIOUS_STRINGS = [
    # Ransom note words
    'encrypted', 'pay', 'bitcoin', 'ransom', 'decrypt', 'unlock', 'payment',
    'before', 'delete', 'files', 'restore', 'deadline', 'hours', 'wallet',
    
    # Commands
    'vssadmin delete shadows', 'bcdedit /set {default} recoveryenabled no',
    'cipher /w', 'wmic shadowcopy delete',
    
    # Ransomware extensions
    '.encrypted', '.locked', '.payforunlock', '.fun', '.crypt', '.cry',
    '.crypto', '.rage', '.paybtc', '.pays', '.paym', '.wallet', '.wncry',
    '.cerber', '.encrypted', '.enc', '.crypted', '.locked', '.locky',
]

# Regular expressions for suspicious patterns
IP_REGEX = r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
URL_REGEX = r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+'
EXTENSION_REGEX = r'\.(jpg|jpeg|png|gif|doc|docx|xls|xlsx|pdf|txt|zip|rar|ppt|pptx|html|htm|mp3|mp4|avi|mov)'


class StaticAnalyzer:
    def __init__(self, file_path):
        self.file_path = file_path
        self.pe = None
        self.file_data = None
        self.strings = None
        self.import_functions = []
        self.suspicious_score = 0
        self.max_score = 100
        self.findings = {}
        
    def load_file(self):
        """Load the PE file and read its content."""
        try:
            self.pe = pefile.PE(self.file_path)
            with open(self.file_path, 'rb') as f:
                self.file_data = f.read()
            return True
        except Exception as e:
            print(f"Error loading file: {e}")
            return False
    
    def extract_strings(self):
        """Extract strings from the binary using the strings command."""
        try:
            output = subprocess.check_output(["strings", self.file_path])
            self.strings = output.decode('utf-8', errors='ignore').split('\n')
            return True
        except Exception as e:
            print(f"Error extracting strings: {e}")
            self.strings = []
            # Try a simple Python implementation as fallback
            printable = set(bytes(range(32, 127)) + b'\r\n\t')
            result = []
            current = b''
            for byte in self.file_data:
                if bytes([byte]) in printable:
                    current += bytes([byte])
                elif current:
                    if len(current) >= 4:  # Only consider strings of length 4 or more
                        result.append(current.decode('ascii', errors='ignore'))
                    current = b''
            self.strings = result
            return False
            
    def analyze_imports(self):
        """Analyze imported DLLs and functions."""
        if not self.pe:
            return

        suspicious_dlls = set()
        suspicious_functions = set()
        
        try:
            for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode('utf-8').lower()
                
                # Check if DLL is suspicious
                if dll_name in SUSPICIOUS_DLLS:
                    suspicious_dlls.add(dll_name)
                
                # Extract imported functions
                for imp in entry.imports:
                    if imp.name:
                        func_name = imp.name.decode('utf-8')
                        self.import_functions.append(func_name)
                        
                        # Check if function is suspicious
                        for sus_func in SUSPICIOUS_FUNCTIONS:
                            if sus_func in func_name:
                                suspicious_functions.add(func_name)
                                
            # Calculate score based on imports
            dll_score = min(10, len(suspicious_dlls) * 2)
            func_score = min(25, len(suspicious_functions) * 1.5)
            
            self.suspicious_score += dll_score + func_score
            self.findings['suspicious_dlls'] = list(suspicious_dlls)
            self.findings['suspicious_functions'] = list(suspicious_functions)
            
        except Exception as e:
            print(f"Error analyzing imports: {e}")
    
    def analyze_sections(self):
        """Analyze section names for suspicious patterns."""
        if not self.pe:
            return
            
        suspicious_sections = []
        
        try:
            for section in self.pe.sections:
                section_name = section.Name.decode('utf-8', errors='ignore').strip('\x00')
                
                if section_name not in NORMAL_SECTIONS:
                    suspicious_sections.append(section_name)
            
            # Calculate score based on suspicious sections
            section_score = min(10, len(suspicious_sections) * 2)
            self.suspicious_score += section_score
            self.findings['suspicious_sections'] = suspicious_sections
            
        except Exception as e:
            print(f"Error analyzing sections: {e}")
    
    def analyze_strings(self):
        """Analyze extracted strings for suspicious patterns."""
        if not self.strings:
            return
            
        suspicious_string_matches = []
        ips = []
        urls = []
        extensions = set()
        
        # Count file extensions mentioned
        for string in self.strings:
            # Check for suspicious strings
            for sus_str in SUSPICIOUS_STRINGS:
                if sus_str.lower() in string.lower():
                    suspicious_string_matches.append(string)
            
            # Check for IPs
            ip_matches = re.findall(IP_REGEX, string)
            if ip_matches:
                ips.extend(ip_matches)
            
            # Check for URLs
            url_matches = re.findall(URL_REGEX, string)
            if url_matches:
                urls.extend(url_matches)
            
            # Check for file extensions
            ext_matches = re.findall(EXTENSION_REGEX, string)
            if ext_matches:
                extensions.update(ext_matches)
        
        # Score based on string analysis
        string_score = min(15, len(suspicious_string_matches) * 1.5)
        ip_url_score = min(10, (len(ips) + len(urls)) * 1)
        ext_score = 0
        if len(extensions) > 5:  # Many file extensions is suspicious
            ext_score = min(10, len(extensions))
        
        self.suspicious_score += string_score + ip_url_score + ext_score
        
        self.findings['suspicious_strings'] = suspicious_string_matches[:10]  # Limit to 10 examples
        self.findings['ips'] = ips
        self.findings['urls'] = urls
        self.findings['file_extensions'] = list(extensions)
    
    def calculate_entropy(self):
        """Calculate Shannon entropy of the file."""
        if not self.file_data:
            return 0
            
        # Count byte occurrences
        byte_counts = Counter(self.file_data)
        file_size = len(self.file_data)
        
        # Calculate entropy
        entropy = 0
        for count in byte_counts.values():
            probability = count / file_size
            entropy -= probability * math.log2(probability)
        
        # Score based on entropy (typical packed or encrypted files have high entropy >7)
        entropy_score = 0
        if entropy > 7.5:
            entropy_score = 20  # Very high entropy is very suspicious
        elif entropy > 7.0:
            entropy_score = 15
        elif entropy > 6.5:
            entropy_score = 10
        
        self.suspicious_score += entropy_score
        self.findings['entropy'] = entropy
        
        return entropy
    
    def create_yara_rule(self):
        """Create a simple YARA rule based on findings."""
        if not self.findings:
            return None
            
        rule_template = """
rule Potential_Ransomware {
    meta:
        description = "Potential ransomware detected"
        score = %d
    strings:
        $sus_str1 = "encrypted" nocase
        $sus_str2 = "pay" nocase
        $sus_str3 = "bitcoin" nocase
        $sus_str4 = "ransom" nocase
        $sus_cmd1 = "vssadmin delete shadows" nocase
        $sus_cmd2 = "bcdedit /set {default} recoveryenabled no" nocase
    condition:
        uint16(0) == 0x5A4D and 
        (
            2 of ($sus_str*) or
            any of ($sus_cmd*) or
            entropy > 7.5
        )
}
"""
        return rule_template % self.suspicious_score
        
    def analyze(self):
        """Run all analysis methods."""
        if not self.load_file():
            return False
            
        self.extract_strings()
        self.analyze_imports()
        self.analyze_sections()
        self.analyze_strings()
        entropy = self.calculate_entropy()
        
        # Generate a summary report
        report = {
            'file_path': self.file_path,
            'file_size': len(self.file_data),
            'entropy': entropy,
            'suspicious_score': self.suspicious_score,
            'risk_level': self.get_risk_level(),
            'findings': self.findings
        }
        
        return report
    
    def get_risk_level(self):
        """Convert score to risk level."""
        if self.suspicious_score >= 75:
            return "HIGH"
        elif self.suspicious_score >= 50:
            return "MEDIUM"
        elif self.suspicious_score >= 25:
            return "LOW"
        else:
            return "CLEAN"


def print_report(report):
    """Print a formatted report of the analysis."""
    print("\n" + "="*60)
    print(f"STATIC MALWARE ANALYSIS REPORT")
    print("="*60)
    
    print(f"\nFILE: {report['file_path']}")
    print(f"SIZE: {report['file_size']} bytes")
    print(f"ENTROPY: {report['entropy']:.6f} (Normal: ~5.5-6.5, Suspicious: >7.0)")
    print(f"RISK SCORE: {report['suspicious_score']}/100")
    print(f"RISK LEVEL: {report['risk_level']}")
    
    print("\nFINDINGS:")
    findings = report['findings']
    
    if 'suspicious_dlls' in findings and findings['suspicious_dlls']:
        print("\n  Suspicious DLLs:")
        for dll in findings['suspicious_dlls']:
            print(f"    - {dll}")
    
    if 'suspicious_functions' in findings and findings['suspicious_functions']:
        print("\n  Suspicious Functions:")
        # Print up to 10 functions to avoid overwhelming output
        for func in findings['suspicious_functions'][:10]:
            print(f"    - {func}")
        if len(findings['suspicious_functions']) > 10:
            print(f"    - ... ({len(findings['suspicious_functions']) - 10} more)")
    
    if 'suspicious_sections' in findings and findings['suspicious_sections']:
        print("\n  Suspicious Section Names:")
        for section in findings['suspicious_sections']:
            print(f"    - {section}")
    
    if 'suspicious_strings' in findings and findings['suspicious_strings']:
        print("\n  Suspicious Strings:")
        for string in findings['suspicious_strings'][:10]:  # Limit to 10
            if len(string) > 60:
                string = string[:57] + "..."
            print(f"    - {string}")
    
    if 'ips' in findings and findings['ips']:
        print("\n  IP Addresses:")
        for ip in findings['ips'][:5]:  # Limit to 5
            print(f"    - {ip}")
        if len(findings['ips']) > 5:
            print(f"    - ... ({len(findings['ips']) - 5} more)")
    
    if 'urls' in findings and findings['urls']:
        print("\n  URLs:")
        for url in findings['urls'][:5]:  # Limit to 5
            print(f"    - {url}")
        if len(findings['urls']) > 5:
            print(f"    - ... ({len(findings['urls']) - 5} more)")
    
    if 'file_extensions' in findings and findings['file_extensions']:
        print("\n  Referenced File Extensions:")
        print(f"    - {', '.join(findings['file_extensions'])}")
    
    print("\nRECOMMENDATION:")
    if report['risk_level'] == "HIGH":
        print("  This file shows strong indicators of ransomware behavior.")
        print("  Recommend immediate quarantine and further investigation.")
    elif report['risk_level'] == "MEDIUM":
        print("  This file shows some suspicious characteristics.")
        print("  Recommend scanning with additional tools and caution before use.")
    elif report['risk_level'] == "LOW":
        print("  This file has few suspicious indicators but warrants caution.")
        print("  Recommend scanning with additional tools before use.")
    else:
        print("  This file appears to be clean based on static analysis.")
        print("  No suspicious indicators found.")
    
    print("\nDISCLAIMER:")
    print("  This is a simple static analysis and may generate false positives.")
    print("  For production use, combine with dynamic analysis and updated signatures.")
    print("="*60 + "\n")


def main():
    parser = argparse.ArgumentParser(description='Static Analysis Antimalware Tool')
    parser.add_argument('file', help='Path to the executable file to analyze')
    parser.add_argument('-q', '--quiet', action='store_true', help='Quiet mode (only show risk level)')
    args = parser.parse_args()
    
    if not os.path.exists(args.file):
        print(f"Error: File '{args.file}' not found.")
        return 1
    
    analyzer = StaticAnalyzer(args.file)
    report = analyzer.analyze()
    
    if not report:
        print("Analysis failed.")
        return 1
    
    if args.quiet:
        print(f"Risk Level: {report['risk_level']} (Score: {report['suspicious_score']}/100)")
    else:
        print_report(report)
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
